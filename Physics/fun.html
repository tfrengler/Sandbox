<!DOCTYPE html>

<html>
<head>
	<title>TEST</title>
	<meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
	<meta name="author" content="Thomas Frengler" />

	<style type="text/css">
		html, body {
			height: 100%;
			width: 100%;
		}

		canvas {
			margin-left: 1em;
			display: inline-block;
			width: 1024px;
			height: 768px;
			border-style: solid;
			border-color: black;
			border-width: 2px;
		}

		#controls {
			margin-left: 1em;
			display: inline-flex;
			flex-direction: column;
			position: absolute;
		}

		#controls > div {
			margin-bottom: 1em;
		}
	</style>

	<script type="text/javascript" src="vector.js"></script>
	<script type="text/javascript" src="entity.js"></script>
	<script type="text/javascript" src="system.js"></script>
	<script type="text/javascript" src="shapes.js"></script>

	<script type="text/javascript">
		"use strict";

		var drawContext;
		var canvas;
		var objects = [];
		var direction;
		var output;
		var target;
		var running = false;
		var mouseIsDown = false;
		var canvasOffsets = Object.seal({
			x: 0,
			y: 0
		});

		const computeCanvasOffsets = function() {
			let canvasStyles = getComputedStyle(canvas);
			let borderWidthTop = parseInt(canvasStyles.borderTopWidth);
			let borderWidthBottom = parseInt(canvasStyles.borderBottomWidth);
			let borderWidthLeft = parseInt(canvasStyles.borderLeftWidth);
			let borderWidthRight = parseInt(canvasStyles.borderRightWidth);

			let paddingWidthTop = parseInt(canvasStyles.paddingTop);
			let paddingWidthBottom = parseInt(canvasStyles.paddingBottom);
			let paddingWidthLeft = parseInt(canvasStyles.paddingLeft);
			let paddingWidthRight = parseInt(canvasStyles.paddingRight);

			let canvasBoxDimensions = canvas.getBoundingClientRect();
			// The scale is for interpolating between the actual dimensions of the canvas (on the screen) and the size of the draw buffer
			let scaleX = canvas.width / (borderWidthLeft + borderWidthRight) + canvasBoxDimensions.width + (paddingWidthLeft + paddingWidthRight); // relationship bitmap vs. element for X
      		let scaleY = canvas.height / (borderWidthTop + borderWidthBottom) + canvasBoxDimensions.height + (paddingWidthTop + paddingWidthBottom);  // relationship bitmap vs. element for Y

			canvasOffsets.x = borderWidthLeft + canvasBoxDimensions.left + (paddingWidthLeft + paddingWidthRight) * scaleX;
			canvasOffsets.y = borderWidthTop + canvasBoxDimensions.top + (paddingWidthTop + paddingWidthBottom) * scaleY;

			console.log("Canvas offsets computed");
		};

		window.onload = function() {

			canvas = document.getElementById("canvas");
			drawContext = canvas.getContext("2d");
			output = document.getElementById("output");

			document.getElementById("Wind").value = System.wind;
			document.getElementById("Gravity").value = System.gravity;
			document.getElementById("Air").value = System.airFriction;
			document.getElementById("Ground").value = System.surfaceFriction;

			document.getElementById("Wind").addEventListener("change", (event)=> System.wind = parseFloat(event.srcElement.value) || 0.0);
			document.getElementById("Gravity").addEventListener("change", (event)=> System.gravity = parseFloat(event.srcElement.value) || 0.0);
			document.getElementById("Air").addEventListener("change", (event)=> System.airFriction = parseFloat(event.srcElement.value) || 0.0);
			document.getElementById("Ground").addEventListener("change", (event)=> System.surfaceFriction = parseFloat(event.srcElement.value) || 0.0);

			window.addEventListener("resize", computeCanvasOffsets);

			document.getElementById("run").addEventListener("click", (event)=> {
				if (running === true) return;

				running = true;
				main(false);
			});
			document.getElementById("pause").addEventListener("click", (event)=> {
				running = false;
			});
			document.getElementById("step").addEventListener("click", (event)=> {
				if (running === true) return;
				running = true;
				main(true);
			});
			document.getElementById("reset").addEventListener("click", (event)=> {
				running = false;
				setup();
			});

			canvas.addEventListener("mousemove", (event)=> {
				let realX = event.clientX - canvasOffsets.x;
				let realY = event.clientY - canvasOffsets.y;

				output.innerText = `X: ${realX} | Y: ${realY}`;

				if (mouseIsDown)
					target = new Vector(realX, realY);
			});

			canvas.addEventListener("mousedown", (event)=> {
				mouseIsDown = true;
			});

			canvas.addEventListener("mouseup", (event)=> {
				mouseIsDown = false;
				target = null;
			});

			// Setting the draw buffer size, scaled to the pixel depth of the device
			canvas.width = canvas.clientWidth * window.devicePixelRatio;
			canvas.height = canvas.clientHeight * window.devicePixelRatio;

			// Normalize coordinate system to use css pixels.
			drawContext.scale(window.devicePixelRatio, window.devicePixelRatio);
			computeCanvasOffsets();

			setup();
			console.log("Ready!");
		};

		const setup = function() {
			objects = [];
			objects.push(new Entity(new Vector(canvas.width / 2 - 60, canvas.height / 2), 7, 5, new Square(50)));
			objects.push(new Entity(new Vector(canvas.width / 2, canvas.height / 2), 5, 4, new Rectangle(25, 50)));
			objects.push(new Entity(new Vector(canvas.width / 2 + 60, canvas.height / 2), 3, 2, new Circle(50, null, "green")));
			direction = new Vector();

			System.render(objects);
		};

		const main = function(step) {
			if (!running) return false;

			let parameters = [objects, target || null];
			System.update.apply(System, parameters);

			if (step === true) {
				running = false;
				return;
			};
			
			window.requestAnimationFrame(main);
		};

		const testRotate = function() {
			drawContext.translate(objects[0].location.x, objects[0].location.y);
			drawContext.rotate(System.radians(45));

			drawContext.strokeStyle  = objects[0].shape.borderColor;
			
			drawContext.rect(
				0 - (objects[0].shape.width / 2),
				0 - (objects[0].shape.height / 2),
				objects[0].shape.width,
				objects[0].shape.height
			);
			drawContext.stroke();

			// drawContext.translate(-1*(objects[0].location.x), -1*(objects[0].location.y));
			// drawContext.rotate(System.radians(-45));
		}
	</script>
</head>

	<body>
		<div>
			<canvas id="canvas" ></canvas>
			<div id="controls">

				<div>
					<input type="number" step="0.001" id="Wind" /><span> WIND</span>
				</div>
				<div>
					<input type="number" step="0.001" id="Gravity" /><span> GRAVITY</span>
				</div>
				<div>
					<input type="number" step="0.001" id="Air" /><span> AIR FRICTION</span>
				</div>
				<div>
					<input type="number" step="0.001" id="Ground" /><span> GROUND FRICTION</span>
				</div>

			</div>
		</div>

		<button id="run">RUN</button>
		<button id="pause">PAUSE</button>
		<button id="step">STEP FORWARD</button>
		<button id="reset">RESET</button>

		<span id="output" >X: 0 | Y: 0</span>
	</body>

</html>